START = ECMAScript ;
EVAL = "/* eval code */" ;
PrimaryExpression -> "THIS" | ObjectLiteral | ( "leftParen" Expression "rightParen" ) | Identifier | ArrayLiteral | Literal ;
Literal -> ( DecimalLiteral | HexIntegerLiteral | StringLiteral | BooleanLiteral | "null" | RegularExpressionLiteral ) ;
ArrayLiteral -> "leftBoxBracket" ( ( Elision )? "rightBoxBracket" | ElementList Elision "rightBoxBracket" | ( ElementList )? "rightBoxBracket" ) ;
ElementList -> ( Elision )? AssignmentExpression ( Elision AssignmentExpression )* ;
Elision -> ( "comma" )+ ;
ObjectLiteral -> "leftBrace" ( PropertyNameAndValueList )? "rightBrace" ;
PropertyNameAndValueList -> PropertyNameAndValue ( "comma" PropertyNameAndValue | "comma" )* ;
PropertyNameAndValue -> PropertyName "colon" AssignmentExpression ;
PropertyName -> Identifier | StringLiteral | DecimalLiteral ;
MemberExpression -> ( ( FunctionExpression | PrimaryExpression ) ( MemberExpressionPart )* ) | AllocationExpression ;
MemberExpressionForIn -> ( ( FunctionExpression | PrimaryExpression ) ( MemberExpressionPart )* ) ;
AllocationExpression -> ( "new" MemberExpression ( ( Arguments ( MemberExpressionPart )* )* ) ) ;
MemberExpressionPart -> ( "leftBoxBracket" Expression "rightBoxBracket" ) | ( "period" Identifier ) ;
CallExpression -> MemberExpression Arguments ( CallExpressionPart )* ;
CallExpressionForIn -> MemberExpressionForIn Arguments ( CallExpressionPart )* ;
CallExpressionPart -> Arguments | ( "leftBoxBracket" Expression "rightBoxBracket" ) | ( "period" Identifier ) ;
Arguments -> "leftParen" ( ArgumentList )? "rightParen" ;
ArgumentList -> AssignmentExpression ( "comma" AssignmentExpression )* ;
LeftHandSideExpression -> CallExpression | MemberExpression ;
LeftHandSideExpressionForIn -> CallExpressionForIn | MemberExpressionForIn ;
PostfixExpression -> LeftHandSideExpression ( PostfixOperator )? ;
PostfixOperator -> ( "plusPlus" | "minusMinus" ) ;
UnaryExpression -> ( PostfixExpression | ( UnaryOperator UnaryExpression )+ ) ;
UnaryOperator -> ( "delete" | "void" | "typeof" | "plusPlus" | "minusMinus" | "plus" | "minus" | "tilde" | "exclamation" ) ;
MultiplicativeExpression -> UnaryExpression ( MultiplicativeOperator UnaryExpression )* ;
MultiplicativeOperator -> ( "asterisk" | "slash" | "percent" ) ;
AdditiveExpression -> MultiplicativeExpression ( AdditiveOperator MultiplicativeExpression )* ;
AdditiveOperator -> ( "plus" | "minus" ) ;
ShiftExpression -> AdditiveExpression ( ShiftOperator AdditiveExpression )* ;
ShiftOperator -> ( "leftBracketLeftBracket" | "rightBracketRightBracket" | "rightBracketRightBracketRightBracket" ) ;
RelationalExpression -> ShiftExpression ( RelationalOperator ShiftExpression )* ;
RelationalOperator -> ( "leftBracket" | "rightBracket" | "leftBracketEqual" | "rightBracketEqual" | "INSTANCEOF" | "in" ) ;
RelationalExpressionNoIn -> ShiftExpression ( RelationalNoInOperator ShiftExpression )* ;
RelationalNoInOperator -> ( "leftBracket" | "rightBracket" | "leftBracketEqual" | "rightBracketEqual" | "INSTANCEOF" ) ;
EqualityExpression -> RelationalExpression ( EqualityOperator RelationalExpression )* ;
EqualityExpressionNoIn -> RelationalExpressionNoIn ( EqualityOperator RelationalExpressionNoIn )* ;
EqualityOperator -> ( "equalEqual" | "exclamationEqual" | "equalEqualEqual" | "exclamationEqualEqual" ) ;
BitwiseANDExpression -> EqualityExpression ( BitwiseANDOperator EqualityExpression )* ;
BitwiseANDExpressionNoIn -> EqualityExpressionNoIn ( BitwiseANDOperator EqualityExpressionNoIn )* ;
BitwiseANDOperator -> "and" ;
BitwiseXORExpression -> BitwiseANDExpression ( BitwiseXOROperator BitwiseANDExpression )* ;
BitwiseXORExpressionNoIn -> BitwiseANDExpressionNoIn ( BitwiseXOROperator BitwiseANDExpressionNoIn )* ;
BitwiseXOROperator -> "caret" ;
BitwiseORExpression -> BitwiseXORExpression ( BitwiseOROperator BitwiseXORExpression )* ;
BitwiseORExpressionNoIn -> BitwiseXORExpressionNoIn ( BitwiseOROperator BitwiseXORExpressionNoIn )* ;
BitwiseOROperator -> "pipe" ;
LogicalANDExpression -> BitwiseORExpression ( LogicalANDOperator BitwiseORExpression )* ;
LogicalANDExpressionNoIn -> BitwiseORExpressionNoIn ( LogicalANDOperator BitwiseORExpressionNoIn )* ;
LogicalANDOperator -> "andAnd" ;
LogicalORExpression -> LogicalANDExpression ( LogicalOROperator LogicalANDExpression )* ;
LogicalORExpressionNoIn -> LogicalANDExpressionNoIn ( LogicalOROperator LogicalANDExpressionNoIn )* ;
LogicalOROperator -> "pipePipe" ;
ConditionalExpression -> LogicalORExpression ( "question" AssignmentExpression "colon" AssignmentExpression )? ;
ConditionalExpressionNoIn -> LogicalORExpressionNoIn ( "question" AssignmentExpression "colon" AssignmentExpressionNoIn )? ;
AssignmentExpression -> ( LeftHandSideExpression AssignmentOperator AssignmentExpression | ConditionalExpression ) ;
AssignmentExpressionNoIn -> ( LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn | ConditionalExpressionNoIn ) ;
AssignmentOperator -> ( "equal" | "asteriskEqual" | "slashEqual" | "percentEqual" | "plusEqual" | "minusEqual" 
                      | "leftBracketLeftBracketEqual" | "rightBracketRightBracketEqual" | "rightBracketRightBracketRightBracketEqual"
                      | "andEqual" | "caretEqual" | "pipeEqual" ) ;
Expression -> AssignmentExpression ( "comma" AssignmentExpression )* ;
ExpressionNoIn -> AssignmentExpressionNoIn ( "comma" AssignmentExpressionNoIn )* ;
Statement -> Block | JScriptVarStatement | VariableStatement | EmptyStatement | LabelledStatement | ExpressionStatement | IfStatement | IterationStatement
            | ContinueStatement | BreakStatement | ImportStatement | ReturnStatement | WithStatement | SwitchStatement | ThrowStatement | TryStatement ;
Block -> "leftBrace" ( StatementList )? "rightBrace" ;
StatementList -> ( Statement )+ ;
VariableStatement -> "var" VariableDeclarationList ( "semicolon" )? ;
VariableDeclarationList -> VariableDeclaration ( "comma" VariableDeclaration )* ;
VariableDeclarationListNoIn -> VariableDeclarationNoIn ( "comma" VariableDeclarationNoIn )* ;
VariableDeclaration -> Identifier ( Initialiser )? ;
VariableDeclarationNoIn -> Identifier ( InitialiserNoIn )? ;
Initialiser -> "equal" AssignmentExpression ;
InitialiserNoIn -> "equal" AssignmentExpressionNoIn ;
EmptyStatement -> "semicolon" ;
ExpressionStatement -> Expression ( "semicolon" )? ;
IfStatement -> "IF" "leftParen" Expression "rightParen" Statement ( "ELSE" Statement )? ;
IterationStatement -> ( "DO" Statement "WHILE" "leftParen" Expression "rightParen" ( "semicolon" )? )
                    | ( "WHILE" "leftParen" Expression "rightParen" Statement )
                    | ( "FOR" "leftParen" ( ExpressionNoIn )? "semicolon" ( Expression )? "semicolon" ( Expression )? "rightParen" Statement )
                    | ( "FOR" "leftParen" "var" VariableDeclarationList "semicolon" ( Expression )? "semicolon" ( Expression )? "rightParen" Statement )
                    | ( "FOR" "leftParen" "var" VariableDeclarationNoIn "in" Expression "rightParen" Statement )
                    | ( "FOR" "leftParen" LeftHandSideExpressionForIn "in" Expression "rightParen" Statement ) ;
ContinueStatement -> "CONTINUE" ( Identifier )? ( "semicolon" )? ;
BreakStatement -> "BREAK" ( Identifier )? ( "semicolon" )? ;
ReturnStatement -> "RETURN" ( Expression )? ( "semicolon" )? ;
WithStatement -> "with" "leftParen" Expression "rightParen" Statement ;
SwitchStatement -> "SWITCH" "leftParen" Expression "rightParen" CaseBlock ;
CaseBlock -> "leftBrace" ( CaseClauses )? ( "rightBrace" | DefaultClause ( CaseClauses )? "rightBrace" ) ;
CaseClauses -> ( CaseClause )+ ;
CaseClause -> ( ( "case" Expression "colon" ) ) ( StatementList )? ;
DefaultClause -> ( ( "default" "colon" ) ) ( StatementList )? ;
LabelledStatement -> Identifier "colon" Statement ;
ThrowStatement -> "THROW" Expression ( "semicolon" )? ;
TryStatement -> "TRY" Block ( ( Finally | Catch ( Finally )? ) ) ;
Catch -> "CATCH" "leftParen" Identifier "rightParen" Block ;
Finally -> "FINALLY" Block ;
FunctionDeclaration -> "function" Identifier ( "leftParen" ( FormalParameterList )? "rightParen" ) FunctionBody ;
FunctionExpression -> "function" ( Identifier )? ( "leftParen" ( FormalParameterList )? "rightParen" ) FunctionBody ;
FormalParameterList -> Identifier ( "comma" Identifier )* ;
FunctionBody -> "leftBrace" ( SourceElements )? "rightBrace" ;
ECMAScript -> ( SourceElements )? ;
SourceElements -> ( SourceElement )+ ;
SourceElement -> FunctionDeclaration | Statement ;
ImportStatement -> "import" Name ( "period" "asterisk" )? "semicolon" ;
Name -> Identifier ( "period" Identifier )* ;
JScriptVarStatement -> "var" JScriptVarDeclarationList ( "semicolon" )? ;
JScriptVarDeclarationList -> JScriptVarDeclaration ( "comma" JScriptVarDeclaration )* ;
JScriptVarDeclaration -> Identifier "colon" Identifier ( Initialiser )? ;
DecimalLiteral : "double" ;
HexIntegerLiteral : "int" ;
StringLiteral : "String" ;
BooleanLiteral : "bool" ;
RegularExpressionLiteral : "String" ;
Identifier : "String" ;
